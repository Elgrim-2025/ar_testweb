<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Chromakey + Touch</title>
    <style>
        * { touch-action: none; }
        body { margin: 0; overflow: hidden; background: #000; }
        #ar-container { position: relative; width: 100vw; height: 100vh; }
        #camera-feed {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; z-index: 1;
        }
        #three-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
        }
        #ui-layer {
            position: absolute; bottom: 30px; left: 0;
            width: 100%; display: flex;
            justify-content: center; gap: 15px;
            z-index: 3; pointer-events: auto;
        }
        button {
            padding: 15px 30px; font-size: 18px; font-weight: bold;
            color: #fff; border: none; border-radius: 50px;
            cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #play-btn { background: linear-gradient(135deg, #2ed573, #1e90ff); }
        #capture-btn { background: linear-gradient(135deg, #ff4757, #ff6b81); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="ar-container">
    <video id="camera-feed" autoplay playsinline muted></video>
    <canvas id="three-canvas"></canvas>
    <div id="ui-layer">
        <button id="play-btn">‚ñ∂Ô∏è Ïû¨ÏÉù</button>
        <button id="capture-btn">üì∏ Ï∫°Ï≤ò</button>
    </div>
</div>

<script>
    // ==========================================
    // 1. ÏÖ∞Ïù¥Îçî ÏΩîÎìú
    // ==========================================
    const VERTEX_SHADER = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;

    const FRAGMENT_SHADER = `
uniform sampler2D tex;
uniform vec3 keyColor;
uniform float similarity;
uniform float smoothness;
uniform float spill;
varying vec2 vUv;

vec2 RGBtoUV(vec3 rgb) {
    return vec2(
        rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5   + 0.5,
        rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081 + 0.5
    );
}

vec4 ProcessChromaKey(vec2 texCoord) {
    vec4 rgba = texture2D(tex, texCoord);
    float chromaDist = distance(RGBtoUV(rgba.rgb), RGBtoUV(keyColor));
    float baseMask = chromaDist - similarity;
    float fullMask = pow(clamp(baseMask / smoothness, 0.0, 1.0), 1.5);
    rgba.a = fullMask;
    float spillVal = pow(clamp(baseMask / spill, 0.0, 1.0), 1.5);
    float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0.0, 1.0);
    rgba.rgb = mix(vec3(desat), rgba.rgb, spillVal);
    return rgba;
}

void main(void) {
    gl_FragColor = ProcessChromaKey(vUv);
}
`;

    // ==========================================
    // 2. Ï†ÑÏó≠ Î≥ÄÏàò
    // ==========================================
    const cameraVideo = document.getElementById('camera-feed');
    const canvas3D = document.getElementById('three-canvas');

    let renderer, scene, camera;
    let chromakeyPlane, effectVideo, videoTexture, chromakeyMaterial;

    // ÌÑ∞Ïπò Ï†úÏñ¥ Î≥ÄÏàò
    const raycaster = new THREE.Raycaster();
    const touchPoint = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // ZÏ∂ï ÌèâÎ©¥

    let isDragging = false;
    let isPinching = false;
    let selectedObject = null;
    let dragOffset = new THREE.Vector3();
    let initialPinchDistance = 0;
    let initialScale = 1;

    // Ïä§ÏºÄÏùº Ï†úÌïú
    const MIN_SCALE = 0.5;
    const MAX_SCALE = 5.0;

    // ==========================================
    // 3. Ïπ¥Î©îÎùº Ïã§Ìñâ
    // ==========================================
    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                audio: false
            });
            cameraVideo.srcObject = stream;
        } catch (err) {
            console.error('Camera Error:', err);
        }
    }

    // ==========================================
    // 4. ÌÅ¨Î°úÎßàÌÇ§ ÎπÑÎîîÏò§ ÏÉùÏÑ±
    // ==========================================
    function createChromakeyVideo() {
        effectVideo = document.createElement('video');
        effectVideo.crossOrigin = 'anonymous';
        effectVideo.muted = true;
        effectVideo.loop = true;
        effectVideo.autoplay = false;
        effectVideo.setAttribute('playsinline', '');
        effectVideo.src = './assets/greenscreen.mp4';
        effectVideo.addEventListener('error', () => createTestPattern());
        effectVideo.load();
        return effectVideo;
    }

    function createTestPattern() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const testTexture = new THREE.CanvasTexture(canvas);

        function draw() {
            ctx.fillStyle = '#32A644';
            ctx.fillRect(0, 0, 512, 512);
            const t = Date.now() * 0.002;
            ctx.fillStyle = '#ff4757';
            ctx.beginPath();
            ctx.arc(256 + Math.sin(t) * 80, 256 + Math.cos(t * 0.7) * 60, 100, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#3742fa';
            ctx.beginPath();
            ctx.arc(256 - Math.sin(t) * 60, 256, 50, 0, Math.PI * 2);
            ctx.fill();
            testTexture.needsUpdate = true;
            requestAnimationFrame(draw);
        }
        chromakeyMaterial.uniforms.tex.value = testTexture;
        draw();
    }

    // ==========================================
    // 5. Three.js Ï¥àÍ∏∞Ìôî
    // ==========================================
    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({
            canvas: canvas3D,
            alpha: true,
            preserveDrawingBuffer: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const video = createChromakeyVideo();
        videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        chromakeyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tex: { value: videoTexture },
                keyColor: { value: new THREE.Color(0x32A644) },
                similarity: { value: 0.095 },
                smoothness: { value: 0.082 },
                spill: { value: 0.214 }
            },
            vertexShader: VERTEX_SHADER,
            fragmentShader: FRAGMENT_SHADER,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const geometry = new THREE.PlaneGeometry(3, 2);
        chromakeyPlane = new THREE.Mesh(geometry, chromakeyMaterial);
        chromakeyPlane.position.set(0, 0, 2);
        scene.add(chromakeyPlane);

        setupTouchControls();
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (videoTexture && effectVideo && !effectVideo.paused) {
            videoTexture.needsUpdate = true;
        }
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==========================================
    // 6. ÌÑ∞Ïπò Ï†úÏñ¥ (ÌïµÏã¨)
    // ==========================================
    function setupTouchControls() {
        const canvas = canvas3D;

        // ÌÑ∞Ïπò Ï¢åÌëúÎ•º Ï†ïÍ∑úÌôîÎêú ÎîîÎ∞îÏù¥Ïä§ Ï¢åÌëúÎ°ú Î≥ÄÌôò
        function getTouchNDC(touch) {
            const rect = canvas.getBoundingClientRect();
            return new THREE.Vector2(
                ((touch.clientX - rect.left) / rect.width) * 2 - 1,
                -((touch.clientY - rect.top) / rect.height) * 2 + 1
            );
        }

        // ÌÑ∞Ïπò ÏßÄÏ†êÏùÑ 3D ÏõîÎìú Ï¢åÌëúÎ°ú Î≥ÄÌôò
        function getWorldPosition(ndc) {
            raycaster.setFromCamera(ndc, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);
            return intersectPoint;
        }

        // Îëê ÏÜêÍ∞ÄÎùΩ ÏÇ¨Ïù¥ Í±∞Î¶¨ Í≥ÑÏÇ∞
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // RaycasterÎ°ú Í∞ùÏ≤¥ ÌûàÌä∏ ÌÖåÏä§Ìä∏
        function getIntersectedObject(ndc) {
            raycaster.setFromCamera(ndc, camera);
            const intersects = raycaster.intersectObject(chromakeyPlane);
            return intersects.length > 0 ? intersects[0] : null;
        }

        // ========== TOUCH START ==========
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();

            const touches = e.targetTouches;

            if (touches.length === 1) {
                // Ìïú ÏÜêÍ∞ÄÎùΩ: ÎìúÎûòÍ∑∏ ÏãúÏûë
                const ndc = getTouchNDC(touches[0]);
                const hit = getIntersectedObject(ndc);

                if (hit) {
                    isDragging = true;
                    isPinching = false;
                    selectedObject = hit.object;

                    // Ïò§ÌîÑÏÖã Í≥ÑÏÇ∞ (Ï†êÌîÑ Î∞©ÏßÄ)
                    const worldPos = getWorldPosition(ndc);
                    dragOffset.copy(selectedObject.position).sub(worldPos);
                }
            } else if (touches.length === 2) {
                // Îëê ÏÜêÍ∞ÄÎùΩ: ÌïÄÏπò Ï§å ÏãúÏûë
                isDragging = false;
                isPinching = true;
                initialPinchDistance = getPinchDistance(touches);
                initialScale = chromakeyPlane.scale.x;
            }
        }, { passive: false });

        // ========== TOUCH MOVE ==========
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();

            const touches = e.targetTouches;

            if (isDragging && touches.length === 1 && selectedObject) {
                // ÎìúÎûòÍ∑∏ Ïù¥Îèô
                const ndc = getTouchNDC(touches[0]);
                const worldPos = getWorldPosition(ndc);

                // Ïò§ÌîÑÏÖã Ï†ÅÏö©ÌïòÏó¨ ÏûêÏó∞Ïä§Îü¨Ïö¥ Ïù¥Îèô
                selectedObject.position.x = worldPos.x + dragOffset.x;
                selectedObject.position.y = worldPos.y + dragOffset.y;
            }

            if (isPinching && touches.length === 2) {
                // ÌïÄÏπò Ï§å
                const currentDistance = getPinchDistance(touches);
                const scale = initialScale * (currentDistance / initialPinchDistance);

                // Ïä§ÏºÄÏùº Ï†úÌïú Ï†ÅÏö©
                const clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
                chromakeyPlane.scale.set(clampedScale, clampedScale, 1);
            }
        }, { passive: false });

        // ========== TOUCH END ==========
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            const touches = e.targetTouches;

            if (touches.length === 0) {
                // Î™®Îì† ÏÜêÍ∞ÄÎùΩ ÎñºÎ©¥ Î¶¨ÏÖã
                isDragging = false;
                isPinching = false;
                selectedObject = null;
            } else if (touches.length === 1 && isPinching) {
                // ÌïÄÏπòÏóêÏÑú Ìïú ÏÜêÍ∞ÄÎùΩÏúºÎ°ú Ï†ÑÌôò
                isPinching = false;
                isDragging = false;
            }
        }, { passive: false });

        // ÎßàÏö∞Ïä§ ÏßÄÏõê (Îç∞Ïä§ÌÅ¨ÌÜ± ÌÖåÏä§Ìä∏Ïö©)
        let isMouseDown = false;

        canvas.addEventListener('mousedown', (e) => {
            const ndc = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            const hit = getIntersectedObject(ndc);
            if (hit) {
                isMouseDown = true;
                selectedObject = hit.object;
                const worldPos = getWorldPosition(ndc);
                dragOffset.copy(selectedObject.position).sub(worldPos);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isMouseDown || !selectedObject) return;
            const ndc = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            const worldPos = getWorldPosition(ndc);
            selectedObject.position.x = worldPos.x + dragOffset.x;
            selectedObject.position.y = worldPos.y + dragOffset.y;
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            selectedObject = null;
        });

        // ÎßàÏö∞Ïä§ Ìú† Ï§å (Îç∞Ïä§ÌÅ¨ÌÜ±)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = chromakeyPlane.scale.x * delta;
            const clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
            chromakeyPlane.scale.set(clampedScale, clampedScale, 1);
        }, { passive: false });
    }

    // ==========================================
    // 7. ÎπÑÎîîÏò§ Ïû¨ÏÉù
    // ==========================================
    async function toggleVideo() {
        if (!effectVideo) return;
        const btn = document.getElementById('play-btn');
        if (effectVideo.paused) {
            try {
                await effectVideo.play();
                btn.textContent = '‚è∏Ô∏è Ï†ïÏßÄ';
            } catch (e) { console.error(e); }
        } else {
            effectVideo.pause();
            btn.textContent = '‚ñ∂Ô∏è Ïû¨ÏÉù';
        }
    }

    // ==========================================
    // 8. Ïä§ÌÅ¨Î¶∞ÏÉ∑
    // ==========================================
    function takeScreenshot() {
        const w = window.innerWidth * window.devicePixelRatio;
        const h = window.innerHeight * window.devicePixelRatio;
        const captureCanvas = document.createElement('canvas');
        captureCanvas.width = w;
        captureCanvas.height = h;
        const ctx = captureCanvas.getContext('2d');

        const vw = cameraVideo.videoWidth || w, vh = cameraVideo.videoHeight || h;
        const tr = w / h, vr = vw / vh;
        let sx, sy, sw, sh;
        if (vr > tr) { sh = vh; sw = vh * tr; sx = (vw - sw) / 2; sy = 0; }
        else { sw = vw; sh = vw / tr; sx = 0; sy = (vh - sh) / 2; }
        ctx.drawImage(cameraVideo, sx, sy, sw, sh, 0, 0, w, h);
        ctx.drawImage(canvas3D, 0, 0, w, h);

        const link = document.createElement('a');
        link.download = `capture-${Date.now()}.png`;
        link.href = captureCanvas.toDataURL('image/png');
        link.click();
    }

    // ==========================================
    // 9. Ï¥àÍ∏∞Ìôî
    // ==========================================
    initThreeJS();
    startCamera();

    document.getElementById('play-btn').addEventListener('click', toggleVideo);
    document.getElementById('capture-btn').addEventListener('click', takeScreenshot);
</script>
</body>
</html>